<?php

class DBLayerCached extends DBLayer
{
	protected $cache = [];

	public static function getFirstWord($table)
	{
		return SQLBuilder::getFirstWord($table); // TODO: Change the autogenerated stub
	}

	public function fetchAll($result, $key = null): array
	{
		$cacheKey = $this->getCacheKey(__METHOD__, func_get_args());
		if (isset($this->cache[$cacheKey])) {
//			llog('HIT', __METHOD__, substr($result, 0, 40));
			return $this->cache[$cacheKey];
		}

//		if ($cacheKey) {
//			llog('MISS', __METHOD__, substr($result, 0, 40));
//		}

		$data = parent::fetchAll($result, $key);
		if ($cacheKey) {
			$this->cache[$cacheKey] = $data;
		}

		return $data;
	}

	protected function getCacheKey(string $method, $args): ?string
	{
		try {
			// Check for PgSql\Result without using collect to avoid autoload issues
			foreach ($args as $arg) {
				if ($arg instanceof PgSql\Result) {
					return null;
				}
			}

			// Process args without collect to avoid potential circular dependencies
			$processedArgs = [];
			foreach ($args as $arg) {
				if ($arg instanceof SQLSelectQuery) {
					$processedArgs[] = $arg->getQuery();
				} else {
					$processedArgs[] = $arg;
				}
			}

			// Use json_encode instead of serialize to avoid object recursion issues
			$serialized = json_encode($processedArgs);
			if ($serialized === false) {
				// If JSON encoding fails, fall back to null (no caching)
				return null;
			}

			return md5($method . $serialized);
		} catch (\Throwable $e) {
			// If anything goes wrong, don't cache
			return null;
		}
	}

	public function fetchAssoc($res): array|false
	{
		$cacheKey = $this->getCacheKey(__METHOD__, func_get_args());
		if (isset($this->cache[$cacheKey])) {
			return $this->cache[$cacheKey];
		}

		$data = parent::fetchAssoc($res);
		if ($cacheKey) {
			$this->cache[$cacheKey] = $data;
		}

		return $data;
	}

	public function fetchAssocSeek($res): array|false
	{
		$cacheKey = $this->getCacheKey(__METHOD__, func_get_args());
		if (isset($this->cache[$cacheKey])) {
			return $this->cache[$cacheKey];
		}

		$data = parent::fetchAssocSeek($res);
		if ($cacheKey) {
			$this->cache[$cacheKey] = $data;
		}

		return $data;
	}

	public function getAllRows($query)
	{
		$cacheKey = $this->getCacheKey(__METHOD__, func_get_args());
		if (isset($this->cache[$cacheKey])) {
			return $this->cache[$cacheKey];
		}

		$data = parent::getAllRows($query);
		if ($cacheKey) {
			$this->cache[$cacheKey] = $data;
		}

		return $data;
	}

	public function getFirstRow($query): array|false
	{
		$cacheKey = $this->getCacheKey(__METHOD__, func_get_args());
		if (isset($this->cache[$cacheKey])) {
			return $this->cache[$cacheKey];
		}

		$data = parent::getFirstRow($query);
		if ($cacheKey) {
			$this->cache[$cacheKey] = $data;
		}

		return $data;
	}

	public function getFirstValue($query): ?string
	{
		$cacheKey = $this->getCacheKey(__METHOD__, func_get_args());
		if (isset($this->cache[$cacheKey])) {
			return $this->cache[$cacheKey];
		}

		$data = parent::getFirstValue($query);
		if ($cacheKey) {
			$this->cache[$cacheKey] = $data;
		}

		return $data;
	}

	public function runInsertQuery($table, array $data, array $where = [])
	{
		$this->clearCache();
		return parent::runInsertQuery($table, $data);
	}

	public function clearCache(): void
	{
		$this->cache = [];
	}

	public function runInsertUpdateQuery($table, array $fields, array $where, array $insert = [])
	{
		$this->clearCache();
		return parent::runInsertUpdateQuery($table, $fields, $where, $insert);
	}

	public function runUpdateQuery($table, array $columns, array $where, $orderBy = '')
	{
		$this->clearCache();
		return parent::runUpdateQuery($table, $columns, $where, $orderBy);
	}

	public function runDeleteQuery($table, array $where)
	{
		$this->clearCache();
		return parent::runDeleteQuery($table, $where);
	}

}
